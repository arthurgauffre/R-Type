<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>R-Type: asio::ip::basic_resolver&lt; InternetProtocol, Executor &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">R-Type
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>asio</b></li><li class="navelem"><b>ip</b></li><li class="navelem"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html">basic_resolver</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classasio_1_1ip_1_1basic__resolver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">asio::ip::basic_resolver&lt; InternetProtocol, Executor &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides endpoint resolution functionality.  
 <a href="classasio_1_1ip_1_1basic__resolver.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="basic__resolver_8hpp_source.html">basic_resolver.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for asio::ip::basic_resolver&lt; InternetProtocol, Executor &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classasio_1_1ip_1_1basic__resolver__inherit__graph.png" border="0" usemap="#aasio_1_1ip_1_1basic__resolver_3_01InternetProtocol_00_01Executor_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aasio_1_1ip_1_1basic__resolver_3_01InternetProtocol_00_01Executor_01_4_inherit__map" id="aasio_1_1ip_1_1basic__resolver_3_01InternetProtocol_00_01Executor_01_4_inherit__map">
<area shape="rect" title="Provides endpoint resolution functionality." alt="" coords="5,80,225,121"/>
<area shape="rect" href="classasio_1_1ip_1_1resolver__base.html" title=" " alt="" coords="31,5,199,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for asio::ip::basic_resolver&lt; InternetProtocol, Executor &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classasio_1_1ip_1_1basic__resolver__coll__graph.png" border="0" usemap="#aasio_1_1ip_1_1basic__resolver_3_01InternetProtocol_00_01Executor_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aasio_1_1ip_1_1basic__resolver_3_01InternetProtocol_00_01Executor_01_4_coll__map" id="aasio_1_1ip_1_1basic__resolver_3_01InternetProtocol_00_01Executor_01_4_coll__map">
<area shape="rect" title="Provides endpoint resolution functionality." alt="" coords="5,80,225,121"/>
<area shape="rect" href="classasio_1_1ip_1_1resolver__base.html" title=" " alt="" coords="31,5,199,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1ip_1_1basic__resolver_1_1rebind__executor.html">rebind_executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebinds the resolver type to another executor.  <a href="structasio_1_1ip_1_1basic__resolver_1_1rebind__executor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8cb7c7662b06c4a05aabd7989b474899"><td class="memItemLeft" align="right" valign="top"><a id="a8cb7c7662b06c4a05aabd7989b474899"></a>
typedef Executor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8cb7c7662b06c4a05aabd7989b474899">executor_type</a></td></tr>
<tr class="memdesc:a8cb7c7662b06c4a05aabd7989b474899"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the executor associated with the object. <br /></td></tr>
<tr class="separator:a8cb7c7662b06c4a05aabd7989b474899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182c54def8cd42b1ef1d3169ad30831f"><td class="memItemLeft" align="right" valign="top"><a id="a182c54def8cd42b1ef1d3169ad30831f"></a>
typedef InternetProtocol&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a182c54def8cd42b1ef1d3169ad30831f">protocol_type</a></td></tr>
<tr class="memdesc:a182c54def8cd42b1ef1d3169ad30831f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The protocol type. <br /></td></tr>
<tr class="separator:a182c54def8cd42b1ef1d3169ad30831f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367b646f4e45c6536a3ff0a8c397453b"><td class="memItemLeft" align="right" valign="top"><a id="a367b646f4e45c6536a3ff0a8c397453b"></a>
typedef InternetProtocol::endpoint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a367b646f4e45c6536a3ff0a8c397453b">endpoint_type</a></td></tr>
<tr class="memdesc:a367b646f4e45c6536a3ff0a8c397453b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The endpoint type. <br /></td></tr>
<tr class="separator:a367b646f4e45c6536a3ff0a8c397453b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b81b8c26c503497c4dc0c67f0ceedf1"><td class="memItemLeft" align="right" valign="top"><a id="a1b81b8c26c503497c4dc0c67f0ceedf1"></a>
typedef <a class="el" href="classasio_1_1ip_1_1basic__resolver__query.html">basic_resolver_query</a>&lt; InternetProtocol &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a1b81b8c26c503497c4dc0c67f0ceedf1">query</a></td></tr>
<tr class="memdesc:a1b81b8c26c503497c4dc0c67f0ceedf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.) The query type. <br /></td></tr>
<tr class="separator:a1b81b8c26c503497c4dc0c67f0ceedf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3dbc8d36448e3cf70439e8388396d9"><td class="memItemLeft" align="right" valign="top"><a id="a0c3dbc8d36448e3cf70439e8388396d9"></a>
typedef <a class="el" href="classasio_1_1ip_1_1basic__resolver__iterator.html">basic_resolver_iterator</a>&lt; InternetProtocol &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a0c3dbc8d36448e3cf70439e8388396d9">iterator</a></td></tr>
<tr class="memdesc:a0c3dbc8d36448e3cf70439e8388396d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.) The iterator type. <br /></td></tr>
<tr class="separator:a0c3dbc8d36448e3cf70439e8388396d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b109bca81f8c555aeba8121c74c57ed"><td class="memItemLeft" align="right" valign="top"><a id="a8b109bca81f8c555aeba8121c74c57ed"></a>
typedef <a class="el" href="classasio_1_1ip_1_1basic__resolver__results.html">basic_resolver_results</a>&lt; InternetProtocol &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a></td></tr>
<tr class="memdesc:a8b109bca81f8c555aeba8121c74c57ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">The results type. <br /></td></tr>
<tr class="separator:a8b109bca81f8c555aeba8121c74c57ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classasio_1_1ip_1_1resolver__base"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classasio_1_1ip_1_1resolver__base')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classasio_1_1ip_1_1resolver__base.html">asio::ip::resolver_base</a></td></tr>
<tr class="memitem:adc4a832e3eafb8db046d64f8d82f9ad8 inherit pub_types_classasio_1_1ip_1_1resolver__base"><td class="memItemLeft" align="right" valign="top"><a id="adc4a832e3eafb8db046d64f8d82f9ad8"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>flags</b> { <br />
&#160;&#160;<b>canonical_name</b> = ASIO_OS_DEF(AI_CANONNAME)
, <b>passive</b> = ASIO_OS_DEF(AI_PASSIVE)
, <b>numeric_host</b> = ASIO_OS_DEF(AI_NUMERICHOST)
, <b>numeric_service</b> = ASIO_OS_DEF(AI_NUMERICSERV)
, <br />
&#160;&#160;<b>v4_mapped</b> = ASIO_OS_DEF(AI_V4MAPPED)
, <b>all_matching</b> = ASIO_OS_DEF(AI_ALL)
, <b>address_configured</b> = ASIO_OS_DEF(AI_ADDRCONFIG)
<br />
 }</td></tr>
<tr class="separator:adc4a832e3eafb8db046d64f8d82f9ad8 inherit pub_types_classasio_1_1ip_1_1resolver__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab3821760e214fe9a743cc25f43a85548"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#ab3821760e214fe9a743cc25f43a85548">basic_resolver</a> (const <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8cb7c7662b06c4a05aabd7989b474899">executor_type</a> &amp;ex)</td></tr>
<tr class="memdesc:ab3821760e214fe9a743cc25f43a85548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct with executor.  <a href="classasio_1_1ip_1_1basic__resolver.html#ab3821760e214fe9a743cc25f43a85548">More...</a><br /></td></tr>
<tr class="separator:ab3821760e214fe9a743cc25f43a85548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5a94a229bbe7e6e93ce82ef833fdc2"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext &gt; </td></tr>
<tr class="memitem:a7b5a94a229bbe7e6e93ce82ef833fdc2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a7b5a94a229bbe7e6e93ce82ef833fdc2">basic_resolver</a> (ExecutionContext &amp;context, constraint_t&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a7b5a94a229bbe7e6e93ce82ef833fdc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct with execution context.  <a href="classasio_1_1ip_1_1basic__resolver.html#a7b5a94a229bbe7e6e93ce82ef833fdc2">More...</a><br /></td></tr>
<tr class="separator:a7b5a94a229bbe7e6e93ce82ef833fdc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cfb814d96c33e2e8da7294b4989de76"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a4cfb814d96c33e2e8da7294b4989de76">basic_resolver</a> (<a class="el" href="classasio_1_1ip_1_1basic__resolver.html">basic_resolver</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a4cfb814d96c33e2e8da7294b4989de76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-construct a <a class="el" href="classasio_1_1ip_1_1basic__resolver.html" title="Provides endpoint resolution functionality.">basic_resolver</a> from another.  <a href="classasio_1_1ip_1_1basic__resolver.html#a4cfb814d96c33e2e8da7294b4989de76">More...</a><br /></td></tr>
<tr class="separator:a4cfb814d96c33e2e8da7294b4989de76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080ee5ebe6caaac47376900e0979af5d"><td class="memTemplParams" colspan="2">template&lt;typename Executor1 &gt; </td></tr>
<tr class="memitem:a080ee5ebe6caaac47376900e0979af5d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a080ee5ebe6caaac47376900e0979af5d">basic_resolver</a> (<a class="el" href="classasio_1_1ip_1_1basic__resolver.html">basic_resolver</a>&lt; InternetProtocol, Executor1 &gt; &amp;&amp;other, constraint_t&lt; is_convertible&lt; Executor1, Executor &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a080ee5ebe6caaac47376900e0979af5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-construct a <a class="el" href="classasio_1_1ip_1_1basic__resolver.html" title="Provides endpoint resolution functionality.">basic_resolver</a> from another.  <a href="classasio_1_1ip_1_1basic__resolver.html#a080ee5ebe6caaac47376900e0979af5d">More...</a><br /></td></tr>
<tr class="separator:a080ee5ebe6caaac47376900e0979af5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49b248faaebe093d94980342ecd57ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html">basic_resolver</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#ae49b248faaebe093d94980342ecd57ca">operator=</a> (<a class="el" href="classasio_1_1ip_1_1basic__resolver.html">basic_resolver</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:ae49b248faaebe093d94980342ecd57ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-assign a <a class="el" href="classasio_1_1ip_1_1basic__resolver.html" title="Provides endpoint resolution functionality.">basic_resolver</a> from another.  <a href="classasio_1_1ip_1_1basic__resolver.html#ae49b248faaebe093d94980342ecd57ca">More...</a><br /></td></tr>
<tr class="separator:ae49b248faaebe093d94980342ecd57ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85ce48ec5d1c1853ea41536fd8529d5"><td class="memTemplParams" colspan="2">template&lt;typename Executor1 &gt; </td></tr>
<tr class="memitem:aa85ce48ec5d1c1853ea41536fd8529d5"><td class="memTemplItemLeft" align="right" valign="top">constraint_t&lt; is_convertible&lt; Executor1, Executor &gt;::value, <a class="el" href="classasio_1_1ip_1_1basic__resolver.html">basic_resolver</a> &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#aa85ce48ec5d1c1853ea41536fd8529d5">operator=</a> (<a class="el" href="classasio_1_1ip_1_1basic__resolver.html">basic_resolver</a>&lt; InternetProtocol, Executor1 &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:aa85ce48ec5d1c1853ea41536fd8529d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-assign a <a class="el" href="classasio_1_1ip_1_1basic__resolver.html" title="Provides endpoint resolution functionality.">basic_resolver</a> from another.  <a href="classasio_1_1ip_1_1basic__resolver.html#aa85ce48ec5d1c1853ea41536fd8529d5">More...</a><br /></td></tr>
<tr class="separator:aa85ce48ec5d1c1853ea41536fd8529d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3108c614bb02ebcae46dd6904884680"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#aa3108c614bb02ebcae46dd6904884680">~basic_resolver</a> ()</td></tr>
<tr class="memdesc:aa3108c614bb02ebcae46dd6904884680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the resolver.  <a href="classasio_1_1ip_1_1basic__resolver.html#aa3108c614bb02ebcae46dd6904884680">More...</a><br /></td></tr>
<tr class="separator:aa3108c614bb02ebcae46dd6904884680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0808fa25dddfbb98f0dc0cc473c48f82"><td class="memItemLeft" align="right" valign="top"><a id="a0808fa25dddfbb98f0dc0cc473c48f82"></a>
<a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8cb7c7662b06c4a05aabd7989b474899">executor_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a0808fa25dddfbb98f0dc0cc473c48f82">get_executor</a> () noexcept</td></tr>
<tr class="memdesc:a0808fa25dddfbb98f0dc0cc473c48f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the executor associated with the object. <br /></td></tr>
<tr class="separator:a0808fa25dddfbb98f0dc0cc473c48f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20d9550e4148452b4a52055b7f154df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#ab20d9550e4148452b4a52055b7f154df">cancel</a> ()</td></tr>
<tr class="memdesc:ab20d9550e4148452b4a52055b7f154df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel any asynchronous operations that are waiting on the resolver.  <a href="classasio_1_1ip_1_1basic__resolver.html#ab20d9550e4148452b4a52055b7f154df">More...</a><br /></td></tr>
<tr class="separator:ab20d9550e4148452b4a52055b7f154df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6647ec9f4f03d2b118d4edc882beaa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#ab6647ec9f4f03d2b118d4edc882beaa8">resolve</a> (const <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a1b81b8c26c503497c4dc0c67f0ceedf1">query</a> &amp;q)</td></tr>
<tr class="separator:ab6647ec9f4f03d2b118d4edc882beaa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9478644f336e0a5a2947c8b6fc77bcd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a9478644f336e0a5a2947c8b6fc77bcd5">resolve</a> (const <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a1b81b8c26c503497c4dc0c67f0ceedf1">query</a> &amp;q, asio::error_code &amp;ec)</td></tr>
<tr class="separator:a9478644f336e0a5a2947c8b6fc77bcd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b979a33f44f262e819842b22fb2c05e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a3b979a33f44f262e819842b22fb2c05e">resolve</a> (ASIO_STRING_VIEW_PARAM host, ASIO_STRING_VIEW_PARAM service)</td></tr>
<tr class="memdesc:a3b979a33f44f262e819842b22fb2c05e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform forward resolution of a query to a list of entries.  <a href="classasio_1_1ip_1_1basic__resolver.html#a3b979a33f44f262e819842b22fb2c05e">More...</a><br /></td></tr>
<tr class="separator:a3b979a33f44f262e819842b22fb2c05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511c517a65107760129526f02904afb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a511c517a65107760129526f02904afb6">resolve</a> (ASIO_STRING_VIEW_PARAM host, ASIO_STRING_VIEW_PARAM service, asio::error_code &amp;ec)</td></tr>
<tr class="memdesc:a511c517a65107760129526f02904afb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform forward resolution of a query to a list of entries.  <a href="classasio_1_1ip_1_1basic__resolver.html#a511c517a65107760129526f02904afb6">More...</a><br /></td></tr>
<tr class="separator:a511c517a65107760129526f02904afb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a15bcc7239aa07cf53f274887d390f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a7a15bcc7239aa07cf53f274887d390f2">resolve</a> (ASIO_STRING_VIEW_PARAM host, ASIO_STRING_VIEW_PARAM service, resolver_base::flags resolve_flags)</td></tr>
<tr class="memdesc:a7a15bcc7239aa07cf53f274887d390f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform forward resolution of a query to a list of entries.  <a href="classasio_1_1ip_1_1basic__resolver.html#a7a15bcc7239aa07cf53f274887d390f2">More...</a><br /></td></tr>
<tr class="separator:a7a15bcc7239aa07cf53f274887d390f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe6873dfc7aaf0ca64c38bb5eb4bbf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a3fe6873dfc7aaf0ca64c38bb5eb4bbf6">resolve</a> (ASIO_STRING_VIEW_PARAM host, ASIO_STRING_VIEW_PARAM service, resolver_base::flags resolve_flags, asio::error_code &amp;ec)</td></tr>
<tr class="memdesc:a3fe6873dfc7aaf0ca64c38bb5eb4bbf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform forward resolution of a query to a list of entries.  <a href="classasio_1_1ip_1_1basic__resolver.html#a3fe6873dfc7aaf0ca64c38bb5eb4bbf6">More...</a><br /></td></tr>
<tr class="separator:a3fe6873dfc7aaf0ca64c38bb5eb4bbf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6a9670d69ccafcc0997e5706e9339d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a7d6a9670d69ccafcc0997e5706e9339d">resolve</a> (const <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a182c54def8cd42b1ef1d3169ad30831f">protocol_type</a> &amp;protocol, ASIO_STRING_VIEW_PARAM host, ASIO_STRING_VIEW_PARAM service)</td></tr>
<tr class="memdesc:a7d6a9670d69ccafcc0997e5706e9339d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform forward resolution of a query to a list of entries.  <a href="classasio_1_1ip_1_1basic__resolver.html#a7d6a9670d69ccafcc0997e5706e9339d">More...</a><br /></td></tr>
<tr class="separator:a7d6a9670d69ccafcc0997e5706e9339d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59e94eba4b826adf2cc2f7f607ca456"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#af59e94eba4b826adf2cc2f7f607ca456">resolve</a> (const <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a182c54def8cd42b1ef1d3169ad30831f">protocol_type</a> &amp;protocol, ASIO_STRING_VIEW_PARAM host, ASIO_STRING_VIEW_PARAM service, asio::error_code &amp;ec)</td></tr>
<tr class="memdesc:af59e94eba4b826adf2cc2f7f607ca456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform forward resolution of a query to a list of entries.  <a href="classasio_1_1ip_1_1basic__resolver.html#af59e94eba4b826adf2cc2f7f607ca456">More...</a><br /></td></tr>
<tr class="separator:af59e94eba4b826adf2cc2f7f607ca456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add94d21635523569254d89c643dd2316"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#add94d21635523569254d89c643dd2316">resolve</a> (const <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a182c54def8cd42b1ef1d3169ad30831f">protocol_type</a> &amp;protocol, ASIO_STRING_VIEW_PARAM host, ASIO_STRING_VIEW_PARAM service, resolver_base::flags resolve_flags)</td></tr>
<tr class="memdesc:add94d21635523569254d89c643dd2316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform forward resolution of a query to a list of entries.  <a href="classasio_1_1ip_1_1basic__resolver.html#add94d21635523569254d89c643dd2316">More...</a><br /></td></tr>
<tr class="separator:add94d21635523569254d89c643dd2316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0198f4eb92e043d683ce8d1df0f9177d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a0198f4eb92e043d683ce8d1df0f9177d">resolve</a> (const <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a182c54def8cd42b1ef1d3169ad30831f">protocol_type</a> &amp;protocol, ASIO_STRING_VIEW_PARAM host, ASIO_STRING_VIEW_PARAM service, resolver_base::flags resolve_flags, asio::error_code &amp;ec)</td></tr>
<tr class="memdesc:a0198f4eb92e043d683ce8d1df0f9177d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform forward resolution of a query to a list of entries.  <a href="classasio_1_1ip_1_1basic__resolver.html#a0198f4eb92e043d683ce8d1df0f9177d">More...</a><br /></td></tr>
<tr class="separator:a0198f4eb92e043d683ce8d1df0f9177d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcba5333d182c5b1f562fbabaee177c2"><td class="memTemplParams" colspan="2">template&lt;ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, results_type)) ResolveToken = default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:adcba5333d182c5b1f562fbabaee177c2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#adcba5333d182c5b1f562fbabaee177c2">async_resolve</a> (const <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a1b81b8c26c503497c4dc0c67f0ceedf1">query</a> &amp;q, ResolveToken &amp;&amp;token=default_completion_token_t&lt; <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8cb7c7662b06c4a05aabd7989b474899">executor_type</a> &gt;()) -&gt; decltype(asio::async_initiate&lt; ResolveToken, void(asio::error_code, <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a>)&gt;(declval&lt; initiate_async_resolve &gt;(), token, q))</td></tr>
<tr class="separator:adcba5333d182c5b1f562fbabaee177c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e0bf763a924c519c00bc972e5df2ae"><td class="memTemplParams" colspan="2">template&lt;ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, results_type)) ResolveToken = default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:a83e0bf763a924c519c00bc972e5df2ae"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a83e0bf763a924c519c00bc972e5df2ae">async_resolve</a> (ASIO_STRING_VIEW_PARAM host, ASIO_STRING_VIEW_PARAM service, ResolveToken &amp;&amp;token=default_completion_token_t&lt; <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8cb7c7662b06c4a05aabd7989b474899">executor_type</a> &gt;()) -&gt; decltype(asio::async_initiate&lt; ResolveToken, void(asio::error_code, <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a>)&gt;(declval&lt; initiate_async_resolve &gt;(), token, declval&lt; <a class="el" href="classasio_1_1ip_1_1basic__resolver__query.html">basic_resolver_query</a>&lt; <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a182c54def8cd42b1ef1d3169ad30831f">protocol_type</a> &gt; &amp; &gt;()))</td></tr>
<tr class="memdesc:a83e0bf763a924c519c00bc972e5df2ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously perform forward resolution of a query to a list of entries.  <a href="classasio_1_1ip_1_1basic__resolver.html#a83e0bf763a924c519c00bc972e5df2ae">More...</a><br /></td></tr>
<tr class="separator:a83e0bf763a924c519c00bc972e5df2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0406a7367dc5d95b6463b1a6fc7617d9"><td class="memTemplParams" colspan="2">template&lt;ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, results_type)) ResolveToken = default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:a0406a7367dc5d95b6463b1a6fc7617d9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a0406a7367dc5d95b6463b1a6fc7617d9">async_resolve</a> (ASIO_STRING_VIEW_PARAM host, ASIO_STRING_VIEW_PARAM service, resolver_base::flags resolve_flags, ResolveToken &amp;&amp;token=default_completion_token_t&lt; <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8cb7c7662b06c4a05aabd7989b474899">executor_type</a> &gt;()) -&gt; decltype(asio::async_initiate&lt; ResolveToken, void(asio::error_code, <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a>)&gt;(declval&lt; initiate_async_resolve &gt;(), token, declval&lt; <a class="el" href="classasio_1_1ip_1_1basic__resolver__query.html">basic_resolver_query</a>&lt; <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a182c54def8cd42b1ef1d3169ad30831f">protocol_type</a> &gt; &amp; &gt;()))</td></tr>
<tr class="memdesc:a0406a7367dc5d95b6463b1a6fc7617d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously perform forward resolution of a query to a list of entries.  <a href="classasio_1_1ip_1_1basic__resolver.html#a0406a7367dc5d95b6463b1a6fc7617d9">More...</a><br /></td></tr>
<tr class="separator:a0406a7367dc5d95b6463b1a6fc7617d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6604b264c792b70e54e65f4a2847f86"><td class="memTemplParams" colspan="2">template&lt;ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, results_type)) ResolveToken = default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:ae6604b264c792b70e54e65f4a2847f86"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#ae6604b264c792b70e54e65f4a2847f86">async_resolve</a> (const <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a182c54def8cd42b1ef1d3169ad30831f">protocol_type</a> &amp;protocol, ASIO_STRING_VIEW_PARAM host, ASIO_STRING_VIEW_PARAM service, ResolveToken &amp;&amp;token=default_completion_token_t&lt; <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8cb7c7662b06c4a05aabd7989b474899">executor_type</a> &gt;()) -&gt; decltype(asio::async_initiate&lt; ResolveToken, void(asio::error_code, <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a>)&gt;(declval&lt; initiate_async_resolve &gt;(), token, declval&lt; <a class="el" href="classasio_1_1ip_1_1basic__resolver__query.html">basic_resolver_query</a>&lt; <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a182c54def8cd42b1ef1d3169ad30831f">protocol_type</a> &gt; &amp; &gt;()))</td></tr>
<tr class="memdesc:ae6604b264c792b70e54e65f4a2847f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously perform forward resolution of a query to a list of entries.  <a href="classasio_1_1ip_1_1basic__resolver.html#ae6604b264c792b70e54e65f4a2847f86">More...</a><br /></td></tr>
<tr class="separator:ae6604b264c792b70e54e65f4a2847f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae728d940f99d723e7d44072c3776713c"><td class="memTemplParams" colspan="2">template&lt;ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, results_type)) ResolveToken = default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:ae728d940f99d723e7d44072c3776713c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#ae728d940f99d723e7d44072c3776713c">async_resolve</a> (const <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a182c54def8cd42b1ef1d3169ad30831f">protocol_type</a> &amp;protocol, ASIO_STRING_VIEW_PARAM host, ASIO_STRING_VIEW_PARAM service, resolver_base::flags resolve_flags, ResolveToken &amp;&amp;token=default_completion_token_t&lt; <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8cb7c7662b06c4a05aabd7989b474899">executor_type</a> &gt;()) -&gt; decltype(asio::async_initiate&lt; ResolveToken, void(asio::error_code, <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a>)&gt;(declval&lt; initiate_async_resolve &gt;(), token, declval&lt; <a class="el" href="classasio_1_1ip_1_1basic__resolver__query.html">basic_resolver_query</a>&lt; <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a182c54def8cd42b1ef1d3169ad30831f">protocol_type</a> &gt; &amp; &gt;()))</td></tr>
<tr class="memdesc:ae728d940f99d723e7d44072c3776713c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously perform forward resolution of a query to a list of entries.  <a href="classasio_1_1ip_1_1basic__resolver.html#ae728d940f99d723e7d44072c3776713c">More...</a><br /></td></tr>
<tr class="separator:ae728d940f99d723e7d44072c3776713c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679a5f7eeb482c7d5b363549c3f05dd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a679a5f7eeb482c7d5b363549c3f05dd5">resolve</a> (const <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a367b646f4e45c6536a3ff0a8c397453b">endpoint_type</a> &amp;e)</td></tr>
<tr class="memdesc:a679a5f7eeb482c7d5b363549c3f05dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform reverse resolution of an endpoint to a list of entries.  <a href="classasio_1_1ip_1_1basic__resolver.html#a679a5f7eeb482c7d5b363549c3f05dd5">More...</a><br /></td></tr>
<tr class="separator:a679a5f7eeb482c7d5b363549c3f05dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee08673ac5289caf25beb14881a84df2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#aee08673ac5289caf25beb14881a84df2">resolve</a> (const <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a367b646f4e45c6536a3ff0a8c397453b">endpoint_type</a> &amp;e, asio::error_code &amp;ec)</td></tr>
<tr class="memdesc:aee08673ac5289caf25beb14881a84df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform reverse resolution of an endpoint to a list of entries.  <a href="classasio_1_1ip_1_1basic__resolver.html#aee08673ac5289caf25beb14881a84df2">More...</a><br /></td></tr>
<tr class="separator:aee08673ac5289caf25beb14881a84df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84dced9b9b40d2130194fc5e41c7349c"><td class="memTemplParams" colspan="2">template&lt;ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, results_type)) ResolveToken = default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:a84dced9b9b40d2130194fc5e41c7349c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a84dced9b9b40d2130194fc5e41c7349c">async_resolve</a> (const <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a367b646f4e45c6536a3ff0a8c397453b">endpoint_type</a> &amp;e, ResolveToken &amp;&amp;token=default_completion_token_t&lt; <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8cb7c7662b06c4a05aabd7989b474899">executor_type</a> &gt;()) -&gt; decltype(asio::async_initiate&lt; ResolveToken, void(asio::error_code, <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a>)&gt;(declval&lt; initiate_async_resolve &gt;(), token, e))</td></tr>
<tr class="separator:a84dced9b9b40d2130194fc5e41c7349c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classasio_1_1ip_1_1resolver__base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classasio_1_1ip_1_1resolver__base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classasio_1_1ip_1_1resolver__base.html">asio::ip::resolver_base</a></td></tr>
<tr class="memitem:ab6cc1e7aee770c8617305e858a3cd8cd inherit pro_methods_classasio_1_1ip_1_1resolver__base"><td class="memItemLeft" align="right" valign="top"><a id="ab6cc1e7aee770c8617305e858a3cd8cd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ip_1_1resolver__base.html#ab6cc1e7aee770c8617305e858a3cd8cd">~resolver_base</a> ()</td></tr>
<tr class="memdesc:ab6cc1e7aee770c8617305e858a3cd8cd inherit pro_methods_classasio_1_1ip_1_1resolver__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protected destructor to prevent deletion through this type. <br /></td></tr>
<tr class="separator:ab6cc1e7aee770c8617305e858a3cd8cd inherit pro_methods_classasio_1_1ip_1_1resolver__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename InternetProtocol, typename Executor&gt;<br />
class asio::ip::basic_resolver&lt; InternetProtocol, Executor &gt;</h3>

<p>Provides endpoint resolution functionality. </p>
<p>The <a class="el" href="classasio_1_1ip_1_1basic__resolver.html" title="Provides endpoint resolution functionality.">basic_resolver</a> class template provides the ability to resolve a query to a list of endpoints.</p>
<dl class="section user"><dt>Thread Safety</dt><dd><em>Distinct</em> <em>objects:</em> Safe.<br  />
<em>Shared</em> <em>objects:</em> Unsafe. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab3821760e214fe9a743cc25f43a85548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3821760e214fe9a743cc25f43a85548">&#9670;&nbsp;</a></span>basic_resolver() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html">asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::<a class="el" href="classasio_1_1ip_1_1basic__resolver.html">basic_resolver</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8cb7c7662b06c4a05aabd7989b474899">executor_type</a> &amp;&#160;</td>
          <td class="paramname"><em>ex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct with executor. </p>
<p>This constructor creates a <a class="el" href="classasio_1_1ip_1_1basic__resolver.html" title="Provides endpoint resolution functionality.">basic_resolver</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>The I/O executor that the resolver will use, by default, to dispatch handlers for any asynchronous operations performed on the resolver. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b5a94a229bbe7e6e93ce82ef833fdc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5a94a229bbe7e6e93ce82ef833fdc2">&#9670;&nbsp;</a></span>basic_resolver() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<div class="memtemplate">
template&lt;typename ExecutionContext &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html">asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::<a class="el" href="classasio_1_1ip_1_1basic__resolver.html">basic_resolver</a> </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">constraint_t&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct with execution context. </p>
<p>This constructor creates a <a class="el" href="classasio_1_1ip_1_1basic__resolver.html" title="Provides endpoint resolution functionality.">basic_resolver</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>An execution context which provides the I/O executor that the resolver will use, by default, to dispatch handlers for any asynchronous operations performed on the resolver. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4cfb814d96c33e2e8da7294b4989de76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cfb814d96c33e2e8da7294b4989de76">&#9670;&nbsp;</a></span>basic_resolver() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html">asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::<a class="el" href="classasio_1_1ip_1_1basic__resolver.html">basic_resolver</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html">basic_resolver</a>&lt; InternetProtocol, Executor &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-construct a <a class="el" href="classasio_1_1ip_1_1basic__resolver.html" title="Provides endpoint resolution functionality.">basic_resolver</a> from another. </p>
<p>This constructor moves a resolver from one object to another.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other <a class="el" href="classasio_1_1ip_1_1basic__resolver.html" title="Provides endpoint resolution functionality.">basic_resolver</a> object from which the move will occur.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Following the move, the moved-from object is in the same state as if constructed using the <code><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#ab3821760e214fe9a743cc25f43a85548" title="Construct with executor.">basic_resolver(const executor_type&amp;)</a></code> constructor. </dd></dl>

</div>
</div>
<a id="a080ee5ebe6caaac47376900e0979af5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a080ee5ebe6caaac47376900e0979af5d">&#9670;&nbsp;</a></span>basic_resolver() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<div class="memtemplate">
template&lt;typename Executor1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html">asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::<a class="el" href="classasio_1_1ip_1_1basic__resolver.html">basic_resolver</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html">basic_resolver</a>&lt; InternetProtocol, Executor1 &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">constraint_t&lt; is_convertible&lt; Executor1, Executor &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-construct a <a class="el" href="classasio_1_1ip_1_1basic__resolver.html" title="Provides endpoint resolution functionality.">basic_resolver</a> from another. </p>
<p>This constructor moves a resolver from one object to another.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other <a class="el" href="classasio_1_1ip_1_1basic__resolver.html" title="Provides endpoint resolution functionality.">basic_resolver</a> object from which the move will occur.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Following the move, the moved-from object is in the same state as if constructed using the <code><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#ab3821760e214fe9a743cc25f43a85548" title="Construct with executor.">basic_resolver(const executor_type&amp;)</a></code> constructor. </dd></dl>

</div>
</div>
<a id="aa3108c614bb02ebcae46dd6904884680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3108c614bb02ebcae46dd6904884680">&#9670;&nbsp;</a></span>~basic_resolver()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html">asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::~<a class="el" href="classasio_1_1ip_1_1basic__resolver.html">basic_resolver</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the resolver. </p>
<p>This function destroys the resolver, cancelling any outstanding asynchronous wait operations associated with the resolver as if by calling <code>cancel</code>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0406a7367dc5d95b6463b1a6fc7617d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0406a7367dc5d95b6463b1a6fc7617d9">&#9670;&nbsp;</a></span>async_resolve() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<div class="memtemplate">
template&lt;ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, results_type)) ResolveToken = default_completion_token_t&lt;executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classasio_1_1ip_1_1basic__resolver.html">asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::async_resolve </td>
          <td>(</td>
          <td class="paramtype">ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">resolver_base::flags&#160;</td>
          <td class="paramname"><em>resolve_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResolveToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code>default_completion_token_t&lt;<a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8cb7c7662b06c4a05aabd7989b474899">executor_type</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(
      asio::async_initiate&lt;ResolveToken,
        void (asio::error_code, <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a>)&gt;(
          declval&lt;initiate_async_resolve&gt;(), token,
          declval&lt;<a class="el" href="classasio_1_1ip_1_1basic__resolver__query.html">basic_resolver_query</a>&lt;<a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a182c54def8cd42b1ef1d3169ad30831f">protocol_type</a>&gt;&amp;&gt;()))
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously perform forward resolution of a query to a list of entries. </p>
<p>This function is used to resolve host and service names into a list of endpoint entries. It is an initiating function for an asynchronous_operation, and always returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.</td></tr>
    <tr><td class="paramname">service</td><td>A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.</td></tr>
    <tr><td class="paramname">resolve_flags</td><td>A set of flags that determine how name resolution should be performed. The default flags are suitable for communication with remote hosts. See the <a class="el" href="classasio_1_1ip_1_1resolver__base.html">resolver_base</a> documentation for the set of available flags.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the resolve completes. Potential completion tokens include use_future, use_awaitable, yield_context, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> asio::error_code&amp; error, <span class="comment">// Result of operation.</span></div>
<div class="line">  resolver::results_type results <span class="comment">// Resolved endpoints as a range.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::async_immediate().</td></tr>
  </table>
  </dd>
</dl>
<p>A successful resolve operation is guaranteed to pass a non-empty range to the handler.</p>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(asio::error_code, <a class="code" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a>) </div>
<div class="ttc" id="aclassasio_1_1ip_1_1basic__resolver_html_a8b109bca81f8c555aeba8121c74c57ed"><div class="ttname"><a href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">asio::ip::basic_resolver::results_type</a></div><div class="ttdeci">basic_resolver_results&lt; InternetProtocol &gt; results_type</div><div class="ttdoc">The results type.</div><div class="ttdef"><b>Definition:</b> basic_resolver.hpp:97</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>On POSIX systems, host names may be locally defined in the file <code>/etc/hosts</code>. On Windows, host names may be defined in the file <code>c:\windows\system32\drivers\etc\hosts</code>. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).</dd></dl>
<p>On POSIX systems, service names are typically defined in the file <code>/etc/services</code>. On Windows, service names may be found in the file <code>c:\windows\system32\drivers\etc\services</code>. Operating systems may use additional locations when resolving service names. </p>

</div>
</div>
<a id="a83e0bf763a924c519c00bc972e5df2ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e0bf763a924c519c00bc972e5df2ae">&#9670;&nbsp;</a></span>async_resolve() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<div class="memtemplate">
template&lt;ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, results_type)) ResolveToken = default_completion_token_t&lt;executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classasio_1_1ip_1_1basic__resolver.html">asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::async_resolve </td>
          <td>(</td>
          <td class="paramtype">ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResolveToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code>default_completion_token_t&lt;<a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8cb7c7662b06c4a05aabd7989b474899">executor_type</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(
      asio::async_initiate&lt;ResolveToken,
        void (asio::error_code, <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a>)&gt;(
          declval&lt;initiate_async_resolve&gt;(), token,
          declval&lt;<a class="el" href="classasio_1_1ip_1_1basic__resolver__query.html">basic_resolver_query</a>&lt;<a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a182c54def8cd42b1ef1d3169ad30831f">protocol_type</a>&gt;&amp;&gt;()))
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously perform forward resolution of a query to a list of entries. </p>
<p>This function is used to resolve host and service names into a list of endpoint entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.</td></tr>
    <tr><td class="paramname">service</td><td>A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the resolve completes. Potential completion tokens include use_future, use_awaitable, yield_context, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> asio::error_code&amp; error, <span class="comment">// Result of operation.</span></div>
<div class="line">  resolver::results_type results <span class="comment">// Resolved endpoints as a range.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::async_immediate().</td></tr>
  </table>
  </dd>
</dl>
<p>A successful resolve operation is guaranteed to pass a non-empty range to the handler.</p>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(asio::error_code, <a class="code" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a>) </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>On POSIX systems, host names may be locally defined in the file <code>/etc/hosts</code>. On Windows, host names may be defined in the file <code>c:\windows\system32\drivers\etc\hosts</code>. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).</dd></dl>
<p>On POSIX systems, service names are typically defined in the file <code>/etc/services</code>. On Windows, service names may be found in the file <code>c:\windows\system32\drivers\etc\services</code>. Operating systems may use additional locations when resolving service names. </p>

</div>
</div>
<a id="a84dced9b9b40d2130194fc5e41c7349c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84dced9b9b40d2130194fc5e41c7349c">&#9670;&nbsp;</a></span>async_resolve() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<div class="memtemplate">
template&lt;ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, results_type)) ResolveToken = default_completion_token_t&lt;executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classasio_1_1ip_1_1basic__resolver.html">asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::async_resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a367b646f4e45c6536a3ff0a8c397453b">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResolveToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code>default_completion_token_t&lt;<a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8cb7c7662b06c4a05aabd7989b474899">executor_type</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(
      asio::async_initiate&lt;ResolveToken,
        void (asio::error_code, <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a>)&gt;(
          declval&lt;initiate_async_resolve&gt;(), token, e))
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronously perform reverse resolution of an endpoint to a list of entries. This function is used to asynchronously resolve an endpoint into a list of endpoint entries. It is an initiating function for an asynchronous_operation, and always returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>An endpoint object that determines what endpoints will be returned.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the resolve completes. Potential completion tokens include use_future, use_awaitable, yield_context, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> asio::error_code&amp; error, <span class="comment">// Result of operation.</span></div>
<div class="line">  resolver::results_type results <span class="comment">// Resolved endpoints as a range.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::async_immediate().</td></tr>
  </table>
  </dd>
</dl>
<p>A successful resolve operation is guaranteed to pass a non-empty range to the handler.</p>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(asio::error_code, <a class="code" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a>) </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ae728d940f99d723e7d44072c3776713c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae728d940f99d723e7d44072c3776713c">&#9670;&nbsp;</a></span>async_resolve() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<div class="memtemplate">
template&lt;ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, results_type)) ResolveToken = default_completion_token_t&lt;executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classasio_1_1ip_1_1basic__resolver.html">asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::async_resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a182c54def8cd42b1ef1d3169ad30831f">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">resolver_base::flags&#160;</td>
          <td class="paramname"><em>resolve_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResolveToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code>default_completion_token_t&lt;<a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8cb7c7662b06c4a05aabd7989b474899">executor_type</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(
      asio::async_initiate&lt;ResolveToken,
        void (asio::error_code, <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a>)&gt;(
          declval&lt;initiate_async_resolve&gt;(), token,
          declval&lt;<a class="el" href="classasio_1_1ip_1_1basic__resolver__query.html">basic_resolver_query</a>&lt;<a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a182c54def8cd42b1ef1d3169ad30831f">protocol_type</a>&gt;&amp;&gt;()))
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously perform forward resolution of a query to a list of entries. </p>
<p>This function is used to resolve host and service names into a list of endpoint entries. It is an initiating function for an asynchronous_operation, and always returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol</td><td>A protocol object, normally representing either the IPv4 or IPv6 version of an internet protocol.</td></tr>
    <tr><td class="paramname">host</td><td>A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.</td></tr>
    <tr><td class="paramname">service</td><td>A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.</td></tr>
    <tr><td class="paramname">resolve_flags</td><td>A set of flags that determine how name resolution should be performed. The default flags are suitable for communication with remote hosts. See the <a class="el" href="classasio_1_1ip_1_1resolver__base.html">resolver_base</a> documentation for the set of available flags.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the resolve completes. Potential completion tokens include use_future, use_awaitable, yield_context, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> asio::error_code&amp; error, <span class="comment">// Result of operation.</span></div>
<div class="line">  resolver::results_type results <span class="comment">// Resolved endpoints as a range.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::async_immediate().</td></tr>
  </table>
  </dd>
</dl>
<p>A successful resolve operation is guaranteed to pass a non-empty range to the handler.</p>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(asio::error_code, <a class="code" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a>) </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>On POSIX systems, host names may be locally defined in the file <code>/etc/hosts</code>. On Windows, host names may be defined in the file <code>c:\windows\system32\drivers\etc\hosts</code>. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).</dd></dl>
<p>On POSIX systems, service names are typically defined in the file <code>/etc/services</code>. On Windows, service names may be found in the file <code>c:\windows\system32\drivers\etc\services</code>. Operating systems may use additional locations when resolving service names. </p>

</div>
</div>
<a id="ae6604b264c792b70e54e65f4a2847f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6604b264c792b70e54e65f4a2847f86">&#9670;&nbsp;</a></span>async_resolve() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<div class="memtemplate">
template&lt;ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, results_type)) ResolveToken = default_completion_token_t&lt;executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classasio_1_1ip_1_1basic__resolver.html">asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::async_resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a182c54def8cd42b1ef1d3169ad30831f">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResolveToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code>default_completion_token_t&lt;<a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8cb7c7662b06c4a05aabd7989b474899">executor_type</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(
      asio::async_initiate&lt;ResolveToken,
        void (asio::error_code, <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a>)&gt;(
          declval&lt;initiate_async_resolve&gt;(), token,
          declval&lt;<a class="el" href="classasio_1_1ip_1_1basic__resolver__query.html">basic_resolver_query</a>&lt;<a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a182c54def8cd42b1ef1d3169ad30831f">protocol_type</a>&gt;&amp;&gt;()))
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously perform forward resolution of a query to a list of entries. </p>
<p>This function is used to resolve host and service names into a list of endpoint entries. It is an initiating function for an asynchronous_operation, and always returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol</td><td>A protocol object, normally representing either the IPv4 or IPv6 version of an internet protocol.</td></tr>
    <tr><td class="paramname">host</td><td>A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.</td></tr>
    <tr><td class="paramname">service</td><td>A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the resolve completes. Potential completion tokens include use_future, use_awaitable, yield_context, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> asio::error_code&amp; error, <span class="comment">// Result of operation.</span></div>
<div class="line">  resolver::results_type results <span class="comment">// Resolved endpoints as a range.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::async_immediate().</td></tr>
  </table>
  </dd>
</dl>
<p>A successful resolve operation is guaranteed to pass a non-empty range to the handler.</p>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(asio::error_code, <a class="code" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a>) </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>On POSIX systems, host names may be locally defined in the file <code>/etc/hosts</code>. On Windows, host names may be defined in the file <code>c:\windows\system32\drivers\etc\hosts</code>. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).</dd></dl>
<p>On POSIX systems, service names are typically defined in the file <code>/etc/services</code>. On Windows, service names may be found in the file <code>c:\windows\system32\drivers\etc\services</code>. Operating systems may use additional locations when resolving service names. </p>

</div>
</div>
<a id="adcba5333d182c5b1f562fbabaee177c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcba5333d182c5b1f562fbabaee177c2">&#9670;&nbsp;</a></span>async_resolve() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<div class="memtemplate">
template&lt;ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, results_type)) ResolveToken = default_completion_token_t&lt;executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classasio_1_1ip_1_1basic__resolver.html">asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::async_resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a1b81b8c26c503497c4dc0c67f0ceedf1">query</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResolveToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code>default_completion_token_t&lt;<a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8cb7c7662b06c4a05aabd7989b474899">executor_type</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(
      asio::async_initiate&lt;ResolveToken,
        void (asio::error_code, <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a>)&gt;(
          declval&lt;initiate_async_resolve&gt;(), token, q))
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>(Deprecated: Use overload with separate host and service parameters.) Asynchronously perform forward resolution of a query to a list of entries. This function is used to asynchronously resolve a query into a list of endpoint entries. It is an initiating function for an asynchronous_operation, and always returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>A query object that determines what endpoints will be returned.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the resolve completes. Potential completion tokens include use_future, use_awaitable, yield_context, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> asio::error_code&amp; error, <span class="comment">// Result of operation.</span></div>
<div class="line">  resolver::results_type results <span class="comment">// Resolved endpoints as a range.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::async_immediate().</td></tr>
  </table>
  </dd>
</dl>
<p>A successful resolve operation is guaranteed to pass a non-empty range to the handler.</p>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line">void(asio::error_code, <a class="code" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a>) </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab20d9550e4148452b4a52055b7f154df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20d9550e4148452b4a52055b7f154df">&#9670;&nbsp;</a></span>cancel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasio_1_1ip_1_1basic__resolver.html">asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::cancel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel any asynchronous operations that are waiting on the resolver. </p>
<p>This function forces the completion of any pending asynchronous operations on the host resolver. The handler for each cancelled operation will be invoked with the asio::error::operation_aborted error code. </p>

</div>
</div>
<a id="ae49b248faaebe093d94980342ecd57ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae49b248faaebe093d94980342ecd57ca">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html">basic_resolver</a>&amp; <a class="el" href="classasio_1_1ip_1_1basic__resolver.html">asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html">basic_resolver</a>&lt; InternetProtocol, Executor &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-assign a <a class="el" href="classasio_1_1ip_1_1basic__resolver.html" title="Provides endpoint resolution functionality.">basic_resolver</a> from another. </p>
<p>This assignment operator moves a resolver from one object to another. Cancels any outstanding asynchronous operations associated with the target object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other <a class="el" href="classasio_1_1ip_1_1basic__resolver.html" title="Provides endpoint resolution functionality.">basic_resolver</a> object from which the move will occur.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Following the move, the moved-from object is in the same state as if constructed using the <code><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#ab3821760e214fe9a743cc25f43a85548" title="Construct with executor.">basic_resolver(const executor_type&amp;)</a></code> constructor. </dd></dl>

</div>
</div>
<a id="aa85ce48ec5d1c1853ea41536fd8529d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa85ce48ec5d1c1853ea41536fd8529d5">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<div class="memtemplate">
template&lt;typename Executor1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constraint_t&lt; is_convertible&lt;Executor1, Executor&gt;::value, <a class="el" href="classasio_1_1ip_1_1basic__resolver.html">basic_resolver</a>&amp; &gt; <a class="el" href="classasio_1_1ip_1_1basic__resolver.html">asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html">basic_resolver</a>&lt; InternetProtocol, Executor1 &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-assign a <a class="el" href="classasio_1_1ip_1_1basic__resolver.html" title="Provides endpoint resolution functionality.">basic_resolver</a> from another. </p>
<p>This assignment operator moves a resolver from one object to another. Cancels any outstanding asynchronous operations associated with the target object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other <a class="el" href="classasio_1_1ip_1_1basic__resolver.html" title="Provides endpoint resolution functionality.">basic_resolver</a> object from which the move will occur.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Following the move, the moved-from object is in the same state as if constructed using the <code><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#ab3821760e214fe9a743cc25f43a85548" title="Construct with executor.">basic_resolver(const executor_type&amp;)</a></code> constructor. </dd></dl>

</div>
</div>
<a id="a3b979a33f44f262e819842b22fb2c05e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b979a33f44f262e819842b22fb2c05e">&#9670;&nbsp;</a></span>resolve() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a> <a class="el" href="classasio_1_1ip_1_1basic__resolver.html">asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::resolve </td>
          <td>(</td>
          <td class="paramtype">ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>service</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform forward resolution of a query to a list of entries. </p>
<p>This function is used to resolve host and service names into a list of endpoint entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.</td></tr>
    <tr><td class="paramname">service</td><td>A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range object representing the list of endpoint entries. A successful call to this function is guaranteed to return a non-empty range.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">asio::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>On POSIX systems, host names may be locally defined in the file <code>/etc/hosts</code>. On Windows, host names may be defined in the file <code>c:\windows\system32\drivers\etc\hosts</code>. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).</dd></dl>
<p>On POSIX systems, service names are typically defined in the file <code>/etc/services</code>. On Windows, service names may be found in the file <code>c:\windows\system32\drivers\etc\services</code>. Operating systems may use additional locations when resolving service names. </p>

</div>
</div>
<a id="a511c517a65107760129526f02904afb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511c517a65107760129526f02904afb6">&#9670;&nbsp;</a></span>resolve() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a> <a class="el" href="classasio_1_1ip_1_1basic__resolver.html">asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::resolve </td>
          <td>(</td>
          <td class="paramtype">ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asio::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform forward resolution of a query to a list of entries. </p>
<p>This function is used to resolve host and service names into a list of endpoint entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.</td></tr>
    <tr><td class="paramname">service</td><td>A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range object representing the list of endpoint entries. An empty range is returned if an error occurs. A successful call to this function is guaranteed to return a non-empty range.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>On POSIX systems, host names may be locally defined in the file <code>/etc/hosts</code>. On Windows, host names may be defined in the file <code>c:\windows\system32\drivers\etc\hosts</code>. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).</dd></dl>
<p>On POSIX systems, service names are typically defined in the file <code>/etc/services</code>. On Windows, service names may be found in the file <code>c:\windows\system32\drivers\etc\services</code>. Operating systems may use additional locations when resolving service names. </p>

</div>
</div>
<a id="a7a15bcc7239aa07cf53f274887d390f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a15bcc7239aa07cf53f274887d390f2">&#9670;&nbsp;</a></span>resolve() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a> <a class="el" href="classasio_1_1ip_1_1basic__resolver.html">asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::resolve </td>
          <td>(</td>
          <td class="paramtype">ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">resolver_base::flags&#160;</td>
          <td class="paramname"><em>resolve_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform forward resolution of a query to a list of entries. </p>
<p>This function is used to resolve host and service names into a list of endpoint entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.</td></tr>
    <tr><td class="paramname">service</td><td>A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.</td></tr>
    <tr><td class="paramname">resolve_flags</td><td>A set of flags that determine how name resolution should be performed. The default flags are suitable for communication with remote hosts. See the <a class="el" href="classasio_1_1ip_1_1resolver__base.html">resolver_base</a> documentation for the set of available flags.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range object representing the list of endpoint entries. A successful call to this function is guaranteed to return a non-empty range.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">asio::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>On POSIX systems, host names may be locally defined in the file <code>/etc/hosts</code>. On Windows, host names may be defined in the file <code>c:\windows\system32\drivers\etc\hosts</code>. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).</dd></dl>
<p>On POSIX systems, service names are typically defined in the file <code>/etc/services</code>. On Windows, service names may be found in the file <code>c:\windows\system32\drivers\etc\services</code>. Operating systems may use additional locations when resolving service names. </p>

</div>
</div>
<a id="a3fe6873dfc7aaf0ca64c38bb5eb4bbf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe6873dfc7aaf0ca64c38bb5eb4bbf6">&#9670;&nbsp;</a></span>resolve() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a> <a class="el" href="classasio_1_1ip_1_1basic__resolver.html">asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::resolve </td>
          <td>(</td>
          <td class="paramtype">ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">resolver_base::flags&#160;</td>
          <td class="paramname"><em>resolve_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asio::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform forward resolution of a query to a list of entries. </p>
<p>This function is used to resolve host and service names into a list of endpoint entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.</td></tr>
    <tr><td class="paramname">service</td><td>A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.</td></tr>
    <tr><td class="paramname">resolve_flags</td><td>A set of flags that determine how name resolution should be performed. The default flags are suitable for communication with remote hosts. See the <a class="el" href="classasio_1_1ip_1_1resolver__base.html">resolver_base</a> documentation for the set of available flags.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range object representing the list of endpoint entries. An empty range is returned if an error occurs. A successful call to this function is guaranteed to return a non-empty range.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>On POSIX systems, host names may be locally defined in the file <code>/etc/hosts</code>. On Windows, host names may be defined in the file <code>c:\windows\system32\drivers\etc\hosts</code>. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).</dd></dl>
<p>On POSIX systems, service names are typically defined in the file <code>/etc/services</code>. On Windows, service names may be found in the file <code>c:\windows\system32\drivers\etc\services</code>. Operating systems may use additional locations when resolving service names. </p>

</div>
</div>
<a id="a679a5f7eeb482c7d5b363549c3f05dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679a5f7eeb482c7d5b363549c3f05dd5">&#9670;&nbsp;</a></span>resolve() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a> <a class="el" href="classasio_1_1ip_1_1basic__resolver.html">asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a367b646f4e45c6536a3ff0a8c397453b">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform reverse resolution of an endpoint to a list of entries. </p>
<p>This function is used to resolve an endpoint into a list of endpoint entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>An endpoint object that determines what endpoints will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range object representing the list of endpoint entries. A successful call to this function is guaranteed to return a non-empty range.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">asio::system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee08673ac5289caf25beb14881a84df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee08673ac5289caf25beb14881a84df2">&#9670;&nbsp;</a></span>resolve() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a> <a class="el" href="classasio_1_1ip_1_1basic__resolver.html">asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a367b646f4e45c6536a3ff0a8c397453b">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asio::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform reverse resolution of an endpoint to a list of entries. </p>
<p>This function is used to resolve an endpoint into a list of endpoint entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>An endpoint object that determines what endpoints will be returned.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range object representing the list of endpoint entries. An empty range is returned if an error occurs. A successful call to this function is guaranteed to return a non-empty range. </dd></dl>

</div>
</div>
<a id="a7d6a9670d69ccafcc0997e5706e9339d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d6a9670d69ccafcc0997e5706e9339d">&#9670;&nbsp;</a></span>resolve() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a> <a class="el" href="classasio_1_1ip_1_1basic__resolver.html">asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a182c54def8cd42b1ef1d3169ad30831f">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>service</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform forward resolution of a query to a list of entries. </p>
<p>This function is used to resolve host and service names into a list of endpoint entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol</td><td>A protocol object, normally representing either the IPv4 or IPv6 version of an internet protocol.</td></tr>
    <tr><td class="paramname">host</td><td>A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.</td></tr>
    <tr><td class="paramname">service</td><td>A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range object representing the list of endpoint entries. A successful call to this function is guaranteed to return a non-empty range.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">asio::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>On POSIX systems, host names may be locally defined in the file <code>/etc/hosts</code>. On Windows, host names may be defined in the file <code>c:\windows\system32\drivers\etc\hosts</code>. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).</dd></dl>
<p>On POSIX systems, service names are typically defined in the file <code>/etc/services</code>. On Windows, service names may be found in the file <code>c:\windows\system32\drivers\etc\services</code>. Operating systems may use additional locations when resolving service names. </p>

</div>
</div>
<a id="af59e94eba4b826adf2cc2f7f607ca456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af59e94eba4b826adf2cc2f7f607ca456">&#9670;&nbsp;</a></span>resolve() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a> <a class="el" href="classasio_1_1ip_1_1basic__resolver.html">asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a182c54def8cd42b1ef1d3169ad30831f">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asio::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform forward resolution of a query to a list of entries. </p>
<p>This function is used to resolve host and service names into a list of endpoint entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol</td><td>A protocol object, normally representing either the IPv4 or IPv6 version of an internet protocol.</td></tr>
    <tr><td class="paramname">host</td><td>A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.</td></tr>
    <tr><td class="paramname">service</td><td>A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range object representing the list of endpoint entries. An empty range is returned if an error occurs. A successful call to this function is guaranteed to return a non-empty range.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>On POSIX systems, host names may be locally defined in the file <code>/etc/hosts</code>. On Windows, host names may be defined in the file <code>c:\windows\system32\drivers\etc\hosts</code>. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).</dd></dl>
<p>On POSIX systems, service names are typically defined in the file <code>/etc/services</code>. On Windows, service names may be found in the file <code>c:\windows\system32\drivers\etc\services</code>. Operating systems may use additional locations when resolving service names. </p>

</div>
</div>
<a id="add94d21635523569254d89c643dd2316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add94d21635523569254d89c643dd2316">&#9670;&nbsp;</a></span>resolve() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a> <a class="el" href="classasio_1_1ip_1_1basic__resolver.html">asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a182c54def8cd42b1ef1d3169ad30831f">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">resolver_base::flags&#160;</td>
          <td class="paramname"><em>resolve_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform forward resolution of a query to a list of entries. </p>
<p>This function is used to resolve host and service names into a list of endpoint entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol</td><td>A protocol object, normally representing either the IPv4 or IPv6 version of an internet protocol.</td></tr>
    <tr><td class="paramname">host</td><td>A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.</td></tr>
    <tr><td class="paramname">service</td><td>A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.</td></tr>
    <tr><td class="paramname">resolve_flags</td><td>A set of flags that determine how name resolution should be performed. The default flags are suitable for communication with remote hosts. See the <a class="el" href="classasio_1_1ip_1_1resolver__base.html">resolver_base</a> documentation for the set of available flags.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range object representing the list of endpoint entries. A successful call to this function is guaranteed to return a non-empty range.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">asio::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>On POSIX systems, host names may be locally defined in the file <code>/etc/hosts</code>. On Windows, host names may be defined in the file <code>c:\windows\system32\drivers\etc\hosts</code>. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).</dd></dl>
<p>On POSIX systems, service names are typically defined in the file <code>/etc/services</code>. On Windows, service names may be found in the file <code>c:\windows\system32\drivers\etc\services</code>. Operating systems may use additional locations when resolving service names. </p>

</div>
</div>
<a id="a0198f4eb92e043d683ce8d1df0f9177d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0198f4eb92e043d683ce8d1df0f9177d">&#9670;&nbsp;</a></span>resolve() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a> <a class="el" href="classasio_1_1ip_1_1basic__resolver.html">asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a182c54def8cd42b1ef1d3169ad30831f">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">resolver_base::flags&#160;</td>
          <td class="paramname"><em>resolve_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asio::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform forward resolution of a query to a list of entries. </p>
<p>This function is used to resolve host and service names into a list of endpoint entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol</td><td>A protocol object, normally representing either the IPv4 or IPv6 version of an internet protocol.</td></tr>
    <tr><td class="paramname">host</td><td>A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.</td></tr>
    <tr><td class="paramname">service</td><td>A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.</td></tr>
    <tr><td class="paramname">resolve_flags</td><td>A set of flags that determine how name resolution should be performed. The default flags are suitable for communication with remote hosts. See the <a class="el" href="classasio_1_1ip_1_1resolver__base.html">resolver_base</a> documentation for the set of available flags.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range object representing the list of endpoint entries. An empty range is returned if an error occurs. A successful call to this function is guaranteed to return a non-empty range.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>On POSIX systems, host names may be locally defined in the file <code>/etc/hosts</code>. On Windows, host names may be defined in the file <code>c:\windows\system32\drivers\etc\hosts</code>. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).</dd></dl>
<p>On POSIX systems, service names are typically defined in the file <code>/etc/services</code>. On Windows, service names may be found in the file <code>c:\windows\system32\drivers\etc\services</code>. Operating systems may use additional locations when resolving service names. </p>

</div>
</div>
<a id="ab6647ec9f4f03d2b118d4edc882beaa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6647ec9f4f03d2b118d4edc882beaa8">&#9670;&nbsp;</a></span>resolve() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a> <a class="el" href="classasio_1_1ip_1_1basic__resolver.html">asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a1b81b8c26c503497c4dc0c67f0ceedf1">query</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>(Deprecated: Use overload with separate host and service parameters.) Perform forward resolution of a query to a list of entries. This function is used to resolve a query into a list of endpoint entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>A query object that determines what endpoints will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range object representing the list of endpoint entries. A successful call to this function is guaranteed to return a non-empty range.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">asio::system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9478644f336e0a5a2947c8b6fc77bcd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9478644f336e0a5a2947c8b6fc77bcd5">&#9670;&nbsp;</a></span>resolve() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a8b109bca81f8c555aeba8121c74c57ed">results_type</a> <a class="el" href="classasio_1_1ip_1_1basic__resolver.html">asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a1b81b8c26c503497c4dc0c67f0ceedf1">query</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asio::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>(Deprecated: Use overload with separate host and service parameters.) Perform forward resolution of a query to a list of entries. This function is used to resolve a query into a list of endpoint entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>A query object that determines what endpoints will be returned.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A range object representing the list of endpoint entries. An empty range is returned if an error occurs. A successful call to this function is guaranteed to return a non-empty range. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>3rd_party_lib/asio/asio/include/asio/ip/<a class="el" href="basic__resolver_8hpp_source.html">basic_resolver.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
