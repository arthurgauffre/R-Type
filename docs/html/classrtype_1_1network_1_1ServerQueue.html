<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>R-Type: rtype::network::ServerQueue&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">R-Type
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>rtype</b></li><li class="navelem"><b>network</b></li><li class="navelem"><a class="el" href="classrtype_1_1network_1_1ServerQueue.html">ServerQueue</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classrtype_1_1network_1_1ServerQueue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rtype::network::ServerQueue&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a258e06a65329bc8ae0660d763d31947e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtype_1_1network_1_1ServerQueue.html#a258e06a65329bc8ae0660d763d31947e">ServerQueue</a> ()=default</td></tr>
<tr class="memdesc:a258e06a65329bc8ae0660d763d31947e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor for the <a class="el" href="classrtype_1_1network_1_1ServerQueue.html">ServerQueue</a> class.  <a href="classrtype_1_1network_1_1ServerQueue.html#a258e06a65329bc8ae0660d763d31947e">More...</a><br /></td></tr>
<tr class="separator:a258e06a65329bc8ae0660d763d31947e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f13fbedd0188853717fe5769d6dd37f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtype_1_1network_1_1ServerQueue.html#a9f13fbedd0188853717fe5769d6dd37f">ServerQueue</a> (const <a class="el" href="classrtype_1_1network_1_1ServerQueue.html">ServerQueue</a>&lt; T &gt; &amp;other)=delete</td></tr>
<tr class="memdesc:a9f13fbedd0188853717fe5769d6dd37f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy constructor to prevent copying of <a class="el" href="classrtype_1_1network_1_1ServerQueue.html">ServerQueue</a> instances.  <a href="classrtype_1_1network_1_1ServerQueue.html#a9f13fbedd0188853717fe5769d6dd37f">More...</a><br /></td></tr>
<tr class="separator:a9f13fbedd0188853717fe5769d6dd37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6952fea63966e95e2acb274f8d4d381"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtype_1_1network_1_1ServerQueue.html#ac6952fea63966e95e2acb274f8d4d381">~ServerQueue</a> ()</td></tr>
<tr class="memdesc:ac6952fea63966e95e2acb274f8d4d381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor for the <a class="el" href="classrtype_1_1network_1_1ServerQueue.html">ServerQueue</a> class.  <a href="classrtype_1_1network_1_1ServerQueue.html#ac6952fea63966e95e2acb274f8d4d381">More...</a><br /></td></tr>
<tr class="separator:ac6952fea63966e95e2acb274f8d4d381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13cfd8108c4a53fc0549c7b9f6b8b27"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtype_1_1network_1_1ServerQueue.html#aa13cfd8108c4a53fc0549c7b9f6b8b27">front</a> ()</td></tr>
<tr class="memdesc:aa13cfd8108c4a53fc0549c7b9f6b8b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the front element of the queue.  <a href="classrtype_1_1network_1_1ServerQueue.html#aa13cfd8108c4a53fc0549c7b9f6b8b27">More...</a><br /></td></tr>
<tr class="separator:aa13cfd8108c4a53fc0549c7b9f6b8b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3559d4f26723a069fc09081ceade10"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtype_1_1network_1_1ServerQueue.html#a1e3559d4f26723a069fc09081ceade10">back</a> ()</td></tr>
<tr class="memdesc:a1e3559d4f26723a069fc09081ceade10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the last element in the queue.  <a href="classrtype_1_1network_1_1ServerQueue.html#a1e3559d4f26723a069fc09081ceade10">More...</a><br /></td></tr>
<tr class="separator:a1e3559d4f26723a069fc09081ceade10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08e8b896668d53c83ebee054690096d"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtype_1_1network_1_1ServerQueue.html#ac08e8b896668d53c83ebee054690096d">popFront</a> ()</td></tr>
<tr class="memdesc:ac08e8b896668d53c83ebee054690096d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and returns the front element of the queue.  <a href="classrtype_1_1network_1_1ServerQueue.html#ac08e8b896668d53c83ebee054690096d">More...</a><br /></td></tr>
<tr class="separator:ac08e8b896668d53c83ebee054690096d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105c184c516df5d5e16ac883ecb4c6d7"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtype_1_1network_1_1ServerQueue.html#a105c184c516df5d5e16ac883ecb4c6d7">popBack</a> ()</td></tr>
<tr class="memdesc:a105c184c516df5d5e16ac883ecb4c6d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and returns the last element from the queue.  <a href="classrtype_1_1network_1_1ServerQueue.html#a105c184c516df5d5e16ac883ecb4c6d7">More...</a><br /></td></tr>
<tr class="separator:a105c184c516df5d5e16ac883ecb4c6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1991a4a314d6bb49567d26353514de79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtype_1_1network_1_1ServerQueue.html#a1991a4a314d6bb49567d26353514de79">pushFront</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a1991a4a314d6bb49567d26353514de79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes an element to the front of the queue.  <a href="classrtype_1_1network_1_1ServerQueue.html#a1991a4a314d6bb49567d26353514de79">More...</a><br /></td></tr>
<tr class="separator:a1991a4a314d6bb49567d26353514de79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6704a0a2a9b775c53a5d4a679088ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtype_1_1network_1_1ServerQueue.html#a7c6704a0a2a9b775c53a5d4a679088ea">pushBack</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a7c6704a0a2a9b775c53a5d4a679088ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new element to the end of the queue.  <a href="classrtype_1_1network_1_1ServerQueue.html#a7c6704a0a2a9b775c53a5d4a679088ea">More...</a><br /></td></tr>
<tr class="separator:a7c6704a0a2a9b775c53a5d4a679088ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20412fb2abef5bbca1a59c0c878a50c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtype_1_1network_1_1ServerQueue.html#aa20412fb2abef5bbca1a59c0c878a50c">empty</a> ()</td></tr>
<tr class="memdesc:aa20412fb2abef5bbca1a59c0c878a50c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the queue is empty.  <a href="classrtype_1_1network_1_1ServerQueue.html#aa20412fb2abef5bbca1a59c0c878a50c">More...</a><br /></td></tr>
<tr class="separator:aa20412fb2abef5bbca1a59c0c878a50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ba41521e77d38d8ff0e4555c20571a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtype_1_1network_1_1ServerQueue.html#a88ba41521e77d38d8ff0e4555c20571a">queueSize</a> ()</td></tr>
<tr class="memdesc:a88ba41521e77d38d8ff0e4555c20571a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the queue.  <a href="classrtype_1_1network_1_1ServerQueue.html#a88ba41521e77d38d8ff0e4555c20571a">More...</a><br /></td></tr>
<tr class="separator:a88ba41521e77d38d8ff0e4555c20571a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9cfe071387526b133d8cb91d9d473f"><td class="memItemLeft" align="right" valign="top">std::deque&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtype_1_1network_1_1ServerQueue.html#ade9cfe071387526b133d8cb91d9d473f">getQueue</a> ()</td></tr>
<tr class="memdesc:ade9cfe071387526b133d8cb91d9d473f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a copy of the current queue.  <a href="classrtype_1_1network_1_1ServerQueue.html#ade9cfe071387526b133d8cb91d9d473f">More...</a><br /></td></tr>
<tr class="separator:ade9cfe071387526b133d8cb91d9d473f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d3cf4e452fb304606eca68f769cd24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtype_1_1network_1_1ServerQueue.html#a06d3cf4e452fb304606eca68f769cd24">clear</a> ()</td></tr>
<tr class="memdesc:a06d3cf4e452fb304606eca68f769cd24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all elements from the queue.  <a href="classrtype_1_1network_1_1ServerQueue.html#a06d3cf4e452fb304606eca68f769cd24">More...</a><br /></td></tr>
<tr class="separator:a06d3cf4e452fb304606eca68f769cd24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82329ebf4474beabe08639f52f5c8e57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtype_1_1network_1_1ServerQueue.html#a82329ebf4474beabe08639f52f5c8e57">wait</a> ()</td></tr>
<tr class="memdesc:a82329ebf4474beabe08639f52f5c8e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until the queue is not empty.  <a href="classrtype_1_1network_1_1ServerQueue.html#a82329ebf4474beabe08639f52f5c8e57">More...</a><br /></td></tr>
<tr class="separator:a82329ebf4474beabe08639f52f5c8e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:abb8c9465c9e569c57ec415ce020eba48"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtype_1_1network_1_1ServerQueue.html#abb8c9465c9e569c57ec415ce020eba48">mutexQueue</a></td></tr>
<tr class="memdesc:abb8c9465c9e569c57ec415ce020eba48"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutex to protect access to the queue.  <a href="classrtype_1_1network_1_1ServerQueue.html#abb8c9465c9e569c57ec415ce020eba48">More...</a><br /></td></tr>
<tr class="separator:abb8c9465c9e569c57ec415ce020eba48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3f0bcd290534f9ffb79c96d46b2c88"><td class="memItemLeft" align="right" valign="top">std::deque&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtype_1_1network_1_1ServerQueue.html#a6f3f0bcd290534f9ffb79c96d46b2c88">queue</a></td></tr>
<tr class="memdesc:a6f3f0bcd290534f9ffb79c96d46b2c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">A double-ended queue (deque) that stores elements of type T.  <a href="classrtype_1_1network_1_1ServerQueue.html#a6f3f0bcd290534f9ffb79c96d46b2c88">More...</a><br /></td></tr>
<tr class="separator:a6f3f0bcd290534f9ffb79c96d46b2c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08023d20f023651c5e61200e5af56b9d"><td class="memItemLeft" align="right" valign="top">std::condition_variable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtype_1_1network_1_1ServerQueue.html#a08023d20f023651c5e61200e5af56b9d">blockingCondition</a></td></tr>
<tr class="memdesc:a08023d20f023651c5e61200e5af56b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A condition variable for blocking and notifying threads.  <a href="classrtype_1_1network_1_1ServerQueue.html#a08023d20f023651c5e61200e5af56b9d">More...</a><br /></td></tr>
<tr class="separator:a08023d20f023651c5e61200e5af56b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf6e185a7c8a279f546548cdb73f995"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtype_1_1network_1_1ServerQueue.html#aabf6e185a7c8a279f546548cdb73f995">blockingMutex</a></td></tr>
<tr class="memdesc:aabf6e185a7c8a279f546548cdb73f995"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutex to ensure thread-safe access to shared resources.  <a href="classrtype_1_1network_1_1ServerQueue.html#aabf6e185a7c8a279f546548cdb73f995">More...</a><br /></td></tr>
<tr class="separator:aabf6e185a7c8a279f546548cdb73f995"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a258e06a65329bc8ae0660d763d31947e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258e06a65329bc8ae0660d763d31947e">&#9670;&nbsp;</a></span>ServerQueue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrtype_1_1network_1_1ServerQueue.html">rtype::network::ServerQueue</a>&lt; T &gt;::<a class="el" href="classrtype_1_1network_1_1ServerQueue.html">ServerQueue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor for the <a class="el" href="classrtype_1_1network_1_1ServerQueue.html">ServerQueue</a> class. </p>
<p>This constructor initializes a new instance of the <a class="el" href="classrtype_1_1network_1_1ServerQueue.html">ServerQueue</a> class with default values. </p>

</div>
</div>
<a id="a9f13fbedd0188853717fe5769d6dd37f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f13fbedd0188853717fe5769d6dd37f">&#9670;&nbsp;</a></span>ServerQueue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrtype_1_1network_1_1ServerQueue.html">rtype::network::ServerQueue</a>&lt; T &gt;::<a class="el" href="classrtype_1_1network_1_1ServerQueue.html">ServerQueue</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrtype_1_1network_1_1ServerQueue.html">ServerQueue</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted copy constructor to prevent copying of <a class="el" href="classrtype_1_1network_1_1ServerQueue.html">ServerQueue</a> instances. </p>
<p>This constructor is explicitly deleted to avoid copying of the <a class="el" href="classrtype_1_1network_1_1ServerQueue.html">ServerQueue</a> object, ensuring that each instance is unique and not accidentally duplicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The <a class="el" href="classrtype_1_1network_1_1ServerQueue.html">ServerQueue</a> object to be copied (deleted). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6952fea63966e95e2acb274f8d4d381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6952fea63966e95e2acb274f8d4d381">&#9670;&nbsp;</a></span>~ServerQueue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classrtype_1_1network_1_1ServerQueue.html">rtype::network::ServerQueue</a>&lt; T &gt;::~<a class="el" href="classrtype_1_1network_1_1ServerQueue.html">ServerQueue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual destructor for the <a class="el" href="classrtype_1_1network_1_1ServerQueue.html">ServerQueue</a> class. </p>
<p>This destructor ensures that the queue is cleared when the <a class="el" href="classrtype_1_1network_1_1ServerQueue.html">ServerQueue</a> object is destroyed. It calls the <a class="el" href="classrtype_1_1network_1_1ServerQueue.html#a06d3cf4e452fb304606eca68f769cd24" title="Clears all elements from the queue.">clear()</a> method to remove all elements from the queue. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1e3559d4f26723a069fc09081ceade10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3559d4f26723a069fc09081ceade10">&#9670;&nbsp;</a></span>back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classrtype_1_1network_1_1ServerQueue.html">rtype::network::ServerQueue</a>&lt; T &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the last element in the queue. </p>
<p>This function returns a constant reference to the last element in the queue. It uses a scoped lock to ensure thread safety while accessing the queue.</p>
<dl class="section return"><dt>Returns</dt><dd>const T&amp; A constant reference to the last element in the queue. </dd></dl>

</div>
</div>
<a id="a06d3cf4e452fb304606eca68f769cd24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d3cf4e452fb304606eca68f769cd24">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrtype_1_1network_1_1ServerQueue.html">rtype::network::ServerQueue</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears all elements from the queue. </p>
<p>This function acquires a scoped lock on the mutex to ensure thread safety and then clears all elements from the queue. </p>

</div>
</div>
<a id="aa20412fb2abef5bbca1a59c0c878a50c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa20412fb2abef5bbca1a59c0c878a50c">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classrtype_1_1network_1_1ServerQueue.html">rtype::network::ServerQueue</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the queue is empty. </p>
<p>This function acquires a scoped lock on the mutex to ensure thread safety while checking if the queue is empty.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the queue is empty, false otherwise. </dd></dl>

</div>
</div>
<a id="aa13cfd8108c4a53fc0549c7b9f6b8b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa13cfd8108c4a53fc0549c7b9f6b8b27">&#9670;&nbsp;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classrtype_1_1network_1_1ServerQueue.html">rtype::network::ServerQueue</a>&lt; T &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the front element of the queue. </p>
<p>This function returns a constant reference to the front element of the queue. It uses a scoped lock to ensure thread safety while accessing the queue.</p>
<dl class="section return"><dt>Returns</dt><dd>const T&amp; A constant reference to the front element of the queue. </dd></dl>

</div>
</div>
<a id="ade9cfe071387526b133d8cb91d9d473f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9cfe071387526b133d8cb91d9d473f">&#9670;&nbsp;</a></span>getQueue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt;T&gt; <a class="el" href="classrtype_1_1network_1_1ServerQueue.html">rtype::network::ServerQueue</a>&lt; T &gt;::getQueue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a copy of the current queue. </p>
<p>This function returns a copy of the queue in a thread-safe manner by using a scoped lock to ensure that the queue is not modified while it is being copied.</p>
<dl class="section return"><dt>Returns</dt><dd>std::deque&lt;T&gt; A copy of the current queue. </dd></dl>

</div>
</div>
<a id="a105c184c516df5d5e16ac883ecb4c6d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105c184c516df5d5e16ac883ecb4c6d7">&#9670;&nbsp;</a></span>popBack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classrtype_1_1network_1_1ServerQueue.html">rtype::network::ServerQueue</a>&lt; T &gt;::popBack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes and returns the last element from the queue. </p>
<p>This function acquires a scoped lock on the mutex to ensure thread safety, then moves the last element from the queue and removes it from the queue.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements stored in the queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T The last element from the queue. </dd></dl>

</div>
</div>
<a id="ac08e8b896668d53c83ebee054690096d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac08e8b896668d53c83ebee054690096d">&#9670;&nbsp;</a></span>popFront()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classrtype_1_1network_1_1ServerQueue.html">rtype::network::ServerQueue</a>&lt; T &gt;::popFront </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes and returns the front element of the queue. </p>
<p>This function acquires a scoped lock on the queue's mutex to ensure thread safety, then moves the front element out of the queue and returns it. The front element is removed from the queue in the process.</p>
<dl class="section return"><dt>Returns</dt><dd>T The front element of the queue. </dd></dl>

</div>
</div>
<a id="a7c6704a0a2a9b775c53a5d4a679088ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c6704a0a2a9b775c53a5d4a679088ea">&#9670;&nbsp;</a></span>pushBack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrtype_1_1network_1_1ServerQueue.html">rtype::network::ServerQueue</a>&lt; T &gt;::pushBack </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a new element to the end of the queue. </p>
<p>This function safely adds a new element to the queue by acquiring a lock on the queue's mutex. It then moves the provided value into the queue and notifies one waiting thread, if any, that a new element has been added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The element to be added to the queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1991a4a314d6bb49567d26353514de79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1991a4a314d6bb49567d26353514de79">&#9670;&nbsp;</a></span>pushFront()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrtype_1_1network_1_1ServerQueue.html">rtype::network::ServerQueue</a>&lt; T &gt;::pushFront </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes an element to the front of the queue. </p>
<p>This function adds a new element to the front of the queue. It locks the queue to ensure thread safety, moves the value to avoid unnecessary copies, and then notifies one waiting thread, if any, that a new element is available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The element to be added to the front of the queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88ba41521e77d38d8ff0e4555c20571a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88ba41521e77d38d8ff0e4555c20571a">&#9670;&nbsp;</a></span>queueSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classrtype_1_1network_1_1ServerQueue.html">rtype::network::ServerQueue</a>&lt; T &gt;::queueSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the queue. </p>
<p>This function returns the number of elements currently in the queue. It uses a scoped lock to ensure thread safety while accessing the queue.</p>
<dl class="section return"><dt>Returns</dt><dd>size_t The number of elements in the queue. </dd></dl>

</div>
</div>
<a id="a82329ebf4474beabe08639f52f5c8e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82329ebf4474beabe08639f52f5c8e57">&#9670;&nbsp;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrtype_1_1network_1_1ServerQueue.html">rtype::network::ServerQueue</a>&lt; T &gt;::wait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits until the queue is not empty. </p>
<p>This function blocks the calling thread until the queue becomes non-empty. It uses a condition variable to wait for a notification that the queue has been modified. The function acquires a unique lock on the blockingMutex and waits on the blockingCondition until the queue is no longer empty. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a08023d20f023651c5e61200e5af56b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08023d20f023651c5e61200e5af56b9d">&#9670;&nbsp;</a></span>blockingCondition</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::condition_variable <a class="el" href="classrtype_1_1network_1_1ServerQueue.html">rtype::network::ServerQueue</a>&lt; T &gt;::blockingCondition</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A condition variable for blocking and notifying threads. </p>
<p>This condition variable is used to block one or more threads until another thread modifies a shared variable and notifies the condition variable. It is typically used in conjunction with a std::mutex to protect shared data.</p>
<dl class="section see"><dt>See also</dt><dd>std::mutex </dd>
<dd>
std::unique_lock </dd></dl>

</div>
</div>
<a id="aabf6e185a7c8a279f546548cdb73f995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabf6e185a7c8a279f546548cdb73f995">&#9670;&nbsp;</a></span>blockingMutex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex <a class="el" href="classrtype_1_1network_1_1ServerQueue.html">rtype::network::ServerQueue</a>&lt; T &gt;::blockingMutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A mutex to ensure thread-safe access to shared resources. </p>
<p>This mutex is used to block and synchronize access to critical sections of code, preventing race conditions and ensuring that only one thread can access the protected resource at a time. </p>

</div>
</div>
<a id="abb8c9465c9e569c57ec415ce020eba48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8c9465c9e569c57ec415ce020eba48">&#9670;&nbsp;</a></span>mutexQueue</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex <a class="el" href="classrtype_1_1network_1_1ServerQueue.html">rtype::network::ServerQueue</a>&lt; T &gt;::mutexQueue</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A mutex to protect access to the queue. </p>
<p>This mutex is used to ensure that access to the queue is thread-safe. It should be locked before accessing or modifying the queue and unlocked after the operation is complete. </p>

</div>
</div>
<a id="a6f3f0bcd290534f9ffb79c96d46b2c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f3f0bcd290534f9ffb79c96d46b2c88">&#9670;&nbsp;</a></span>queue</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt;T&gt; <a class="el" href="classrtype_1_1network_1_1ServerQueue.html">rtype::network::ServerQueue</a>&lt; T &gt;::queue</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A double-ended queue (deque) that stores elements of type T. </p>
<p>This container allows for fast insertion and deletion of elements at both the front and the back. It provides random access to elements and is implemented as a sequence of contiguous blocks of memory.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of elements stored in the deque. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>interface/include/<a class="el" href="NetworkQueue_8hpp_source.html">NetworkQueue.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
